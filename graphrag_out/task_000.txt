# Binary Search in F*

Binary search is a classic algorithm used to efficiently locate the position of a target value within a sorted list. The goal is to find the index where a given value `y` should be inserted to maintain the sorted order of the list `xs`. Below, I will provide a few-shot code example in F* and discuss relevant lemmas that can be used to ensure correctness and efficiency.

## F* Code Example: Binary Search

```fstar
module BinarySearch

open FStar.List

let rec binary_search (xs: list int) (y: int) : Tot int =
  let rec aux low high =
    if low >= high then low
    else
      let mid = (low + high) / 2 in
      if List.nth xs mid < y then aux (mid + 1) high
      else aux low mid
  in
  aux 0 (List.length xs)

let test_binary_search () =
  let xs = [1; 3; 5; 7; 9] in
  assert (binary_search xs 4 == 2)
  assert (binary_search xs 10 == 5)
  assert (binary_search xs 0 == 0)
```

### Explanation

- **Function Definition**: The `binary_search` function takes a sorted list `xs` and a value `y`, and returns the index where `y` should be inserted.
- **Auxiliary Function**: The `aux` function performs the binary search using two pointers, `low` and `high`, to track the current search range.
- **Base Case**: If `low` is greater than or equal to `high`, the function returns `low`, indicating the insertion point.
- **Recursive Case**: The function calculates the midpoint `mid` and compares the value at this index with `y`. Depending on the comparison, it adjusts the search range.

## Relevant Lemmas

In F*, lemmas are used to assert properties and ensure correctness. Here are some lemmas that could be relevant for verifying the binary search function:

### Lemma: Sorted List Property

```fstar
val sorted_list_property: xs: list int -> Lemma (requires (sorted xs)) (ensures (forall i j. i < j /\ j < List.length xs ==> List.nth xs i <= List.nth xs j))
let sorted_list_property xs = ()
```

This lemma asserts that for a sorted list `xs`, any element at index `i` is less than or equal to the element at index `j` if `i < j`.

### Lemma: Binary Search Correctness

```fstar
val binary_search_correctness: xs: list int -> y: int -> Lemma (requires (sorted xs)) (ensures (let idx = binary_search xs y in idx == List.length xs \/ (List.nth xs idx >= y /\ (idx == 0 \/ List.nth xs (idx - 1) < y))))
let binary_search_correctness xs y = ()
```

This lemma ensures that the index returned by `binary_search` is correct, meaning that `y` can be inserted at this index to maintain the sorted order.

## Commentary

The binary search algorithm is efficient, with a time complexity of O(log n), making it suitable for large datasets. In F*, the use of lemmas allows developers to formally verify the correctness of the algorithm, ensuring that it behaves as expected for all possible inputs. The provided code example demonstrates how to implement binary search in F* and includes assertions to test its functionality.
